P: O que é uma Activity no contexto do desenvolvimento Android?
A) Uma tela ou interface individual do aplicativo, representada por uma classe que herda de Activity (por exemplo, AppCompatActivity)
B) Um componente utilizado apenas para executar tarefas em segundo plano, sem interface gráfica
C) Um arquivo XML que descreve o layout da interface do usuário
D) Um tipo de Intent usado para comunicar componentes do sistema
R: A)
E: A Activity é fundamental no Android: ela representa uma tela com a qual o usuário pode interagir. Cada Activity possui seu próprio ciclo de vida e geralmente está associada a um layout XML que define a interface dessa tela. Por exemplo, no projeto, a tela principal com botão e texto do sorteador foi implementada como uma Activity (MainActivity). As outras opções estão incorretas: B) descreve um Service (serviço em segundo plano), C) refere-se a layouts XML (que são recursos de interface, não componentes de ciclo de vida), e D) confunde Activity com Intent (Intent é usado para navegar ou acionar componentes, não é ele próprio uma tela). Portanto, a alternativa A melhor define uma Activity. 

P: Em qual arquivo devemos declarar cada Activity nova criada no projeto para que o Android a reconheça e possa iniciá-la?
A) No arquivo AndroidManifest.xml do aplicativo
B) No arquivo build.gradle (Module: app) do projeto
C) No arquivo de layout XML correspondente à Activity
D) No arquivo MainActivity.kt (ou .java) principal do projeto
R: A)
E: Toda Activity precisa ser declarada no AndroidManifest.xml, pois é nesse manifesto que o sistema toma conhecimento dos componentes do aplicativo. No AndroidManifest, cada Activity é listada dentro da tag <application>. Por exemplo, se você criar uma Activity chamada DetalhesActivity para mostrar detalhes de uma bebida no projeto "Bebidas", deve adicionar <activity android:name=".DetalhesActivity">...</activity> no manifest. B) está incorreto porque o build.gradle define configurações de build e dependências, não componentes da aplicação. C) e D) também estão incorretos: o layout XML apenas define a interface visual, e criar a classe da Activity em Kotlin/Java por si só (como em MainActivity.kt) não é suficiente – ela precisa estar listada no manifest para poder ser utilizada pelo sistema. 

P: Por que é recomendável colocar textos exibidos na interface do app no arquivo strings.xml, em vez de escrever diretamente no layout XML ou no código da Activity?
A) Porque isso facilita a tradução do app para outros idiomas e a manutenção dos textos em um só lugar
B) Porque melhora o desempenho do app em tempo de execução
C) Porque é obrigatório pelo Android Studio – o app não compila com textos diretos no layout
D) Porque evita que o texto apareça na interface do Android Studio (Design View) durante o design do layout
R: A)
E: Usar o strings.xml (localizado em res/values/strings.xml) para armazenar textos traz diversos benefícios: centraliza todos os textos em um lugar, facilitando a manutenção e permitindo traduzir o aplicativo facilmente (basta fornecer versões traduzidas desse arquivo para diferentes idiomas). Nos projetos fornecidos, nota-se esse padrão – por exemplo, o título do aplicativo e rótulos de botões são definidos em strings.xml e referenciados via @string/nome_da_string. Isso não impacta diretamente o desempenho (B é falsa) e não é uma obrigatoriedade técnica absoluta do Android Studio (C está incorreta, embora o Android Studio emita avisos de boas práticas). Também não tem relação com a visualização no design editor (D). O principal motivo é mesmo organização e suporte a internacionalização, conforme exposto na alternativa A. 

P: Em um arquivo de layout XML, qual é a diferença entre usar o valor match_parent e wrap_content em atributos de largura ou altura de um componente de UI?
A) match_parent faz a View expandir para ocupar todo o espaço disponível em determinada dimensão, enquanto wrap_content faz a View se ajustar exatamente ao tamanho do seu conteúdo
B) match_parent ajusta o componente ao tamanho mínimo necessário para seu conteúdo, e wrap_content preenche todo o espaço do pai
C) Ambos são sinônimos e fazem a mesma coisa desde as últimas versões do Android
D) wrap_content força o componente a ter tamanho fixo de 100 pixels, e match_parent deixa o tamanho dinâmico
R: A)
E: No layout, match_parent (antigamente chamado fill_parent) indica que a View deve estender-se para ocupar todo o espaço disponível de seu elemento pai na orientação especificada. Já wrap_content indica que a dimensão da View deve ser suficiente apenas para conter seu conteúdo (texto, imagem etc.), sem sobras. Por exemplo, se um Button tem layout_width="match_parent", ele vai alargar-se para toda a largura do pai (por exemplo, toda a tela se for o elemento raiz). Se for layout_width="wrap_content", o botão será apenas largo o bastante para acomodar o texto nele. Portanto, a alternativa A está correta. A alternativa B inverte os conceitos (está trocada) e as alternativas C e D não têm fundamento (não houve fusão dos conceitos e wrap_content não define um valor fixo). 

P: No contexto de layouts Android, o que significa a unidade “dp” (density-independent pixel) e por que ela é utilizada em vez de pixel puro (px)?
A) É uma unidade de medida independente da densidade de tela, o que garante que elementos na interface mantenham aproximadamente o mesmo tamanho físico em diferentes dispositivos, compensando telas de diferentes densidades (dpi)
B) É uma unidade dupla de pixel; cada 1 dp equivale a 2 pixels físicos na tela
C) Significa “dynamic pixel”, adaptando-se automaticamente ao tema claro/escuro do dispositivo
D) É usada apenas para fontes (textos), enquanto px é para outros componentes
R: A)
E: “dp” (density-independent pixel) é uma unidade de medida abstrata que se baseia em uma densidade de referência (160 dpi). O Android a utiliza para que o tamanho dos componentes na tela seja consistente em diferentes aparelhos, independentemente da densidade (quantidade de pixels por polegada) da tela. Por exemplo, um botão definido com 100dp de largura terá aproximadamente o mesmo tamanho físico em um celular de baixa resolução e em um de altíssima resolução, pois o sistema converte dp em pixels reais conforme a densidade do dispositivo. A opção A captura corretamente essa definição. A opção B está incorreta – não há conversão fixa de 1dp = 2px; a conversão varia com a densidade da tela (em uma tela de 160 dpi, 1dp = 1px; em 320 dpi, 1dp = 2px, e assim por diante). As opções C e D também não procedem: dp não tem relação com tema claro/escuro e é usada para dimensões em geral (já textos usam outra unidade recomendada, “sp”, mas dp também pode ser aplicado a textos se desejado, embora sp seja preferível para permitir escalonamento de fontes). 

P: Dentro de uma Activity, qual método podemos usar para obter uma referência a um componente de UI definido em nosso layout XML, a partir de seu ID?
A) Utilizar o método findViewById(R.id.seuComponente)
B) Chamar getElementById("seuComponente")
C) Usar System.findView() passando o nome do componente
D) Acessar diretamente a variável com o nome do ID do componente (por ex., seuComponente)
R: A)
E: Em código Java/Kotlin tradicional (sem usar técnicas mais modernas como ViewBinding ou DataBinding), a forma de obter uma referência de um View definido no XML é chamar findViewById, passando o identificador gerado no R.java (como R.id.seuComponente). Essa chamada pesquisa na hierarquia de Views carregada na Activity aquele ID e retorna, por exemplo, um objeto Button ou TextView correspondente, que então pode ser manipulado no código (definir texto, registrar listeners etc.). Nas aulas, sempre que criávamos um elemento no layout (por exemplo, um TextView com id txtResultado no sorteador), usamos findViewById na Activity para vincular esse TextView a uma variável. As outras alternativas estão incorretas: B parece misturar com nomenclatura de web (document.getElementById do JavaScript), que não se aplica aqui; C é inválida e inexistente; D também está errada, pois não é possível acessar pelo nome do ID diretamente — é necessário usar findViewById ou, quando disponível, ViewBinding (que gera uma classe com propriedades correspondentes às views do layout). 

P: Como podemos executar uma ação quando o usuário clica em um botão via código (programaticamente) em vez de definir no XML?
A) Através do método setOnClickListener do Button, atribuindo a ele um código a ser executado no clique
B) Definindo a propriedade onClickEnabled do Button para true
C) Nomeando o método da Activity igual ao id do Button
D) Chamando o método onClick() diretamente no Button dentro do onCreate() da Activity
R: A)
E: Para reagir ao clique do usuário programaticamente, usamos um listener. Em Android (Java/Kotlin), isso é feito chamando meuBotao.setOnClickListener(...) e passando uma implementação de OnClickListener ou uma lambda (no caso de Kotlin) com o código a executar. Essa é a técnica utilizada nos projetos: por exemplo, no sorteador, no onCreate da Activity definimos algo como buttonSortear.setOnClickListener { /* gera número e exibe */ }. As outras alternativas estão incorretas: B não existe (não há onClickEnabled), C não faz sentido (dar ao método o mesmo nome do id não cria vínculo automático nenhum) e D confunde o fluxo – o método onClick() do Button é chamado internamente quando ocorre o clique, não devemos invocá-lo manualmente. Portanto, usar setOnClickListener é a forma correta. 

P: Qual das alternativas NÃO corresponde a um dos quatro componentes principais do Android? (Os quatro componentes principais são: Activity, Service, BroadcastReceiver e ContentProvider.)
A) Activity
B) Service
C) Fragment
D) BroadcastReceiver
R: C)
E: Os quatro componentes fundamentais do Android, conforme geralmente apresentado em conceitos iniciais, são: Activities (telas com interface para interação do usuário), Services (componentes executando tarefas em segundo plano, sem UI), BroadcastReceivers (receptores de broadcasts/mensagens do sistema ou de apps) e ContentProviders (provedores de dados que permitem compartilhar dados entre aplicações). Fragments não constam nessa lista porque, apesar de muito utilizados para modular interfaces dentro de Activities, eles não são um “componente fundamental” por si só registrado no manifest – um Fragment sempre vive dentro de uma Activity. Portanto, a opção C (Fragment) é a única que não é um componente base independente. Activities (A), Services (B) e BroadcastReceivers (D) fazem parte dos componentes principais (faltou listar ContentProvider nas alternativas, mas a pergunta pede exatamente o que não é um deles). Fragment é um componente de UI subordinado a uma Activity. 

P: Qual é o papel da classe gerada R (R.java) em um projeto Android?
A) Mapear todos os recursos (resources) do projeto – layouts, strings, ids, drawables etc. – em constantes numéricas, permitindo que sejam acessados no código via R.<tipo>.<nome_recurso>
B) Gerenciar em tempo de execução a distribuição de memória para os recursos do aplicativo
C) Armazenar as strings utilizadas pelo aplicativo para rápida referência
D) Iniciar as Activities e outros componentes definidos no manifest durante o lançamento do app
R: A)
E: A classe R (gerada automaticamente pelo Android Studio durante a compilação) é essencial para conectar o código aos recursos definidos externamente. Ela contém identificadores estáticos (IDs) para todos os recursos do projeto: por exemplo, R.layout.activity_main referencia o arquivo de layout activity_main.xml; R.id.btnOk refere-se ao id de um botão “btnOk” definido nesse layout; R.string.app_name refere-se a uma string definida. No código dos projetos (Java/Kotlin), quando usamos findViewById(R.id.algumId) ou setText(R.string.algum_texto), estamos na verdade usando esses campos da classe R. As outras descrições são falsas: B não é função da classe R (quem gerencia memória é o sistema operacional e a VM do Android, não a classe R), C está incorreta pois as strings são armazenadas em arquivos de resource, não dentro da classe R (R apenas aponta para elas), e D nada tem a ver com R (quem inicia componentes é o Android via manifest e Intent, não a classe R). Logo, apenas a alternativa A descreve corretamente a função da classe R. 

P: Para que serve o arquivo build.gradle (Module: app) em um projeto Android Studio?
A) Para configurar o processo de build (compilação) do app e gerenciar dependências, plugins e configurações como versão de SDK, versões de app etc.
B) Para declarar as Activities, serviços e outras componentes do aplicativo
C) Para definir os layouts de interface usados pelas Activities
D) Para armazenar valores de texto, cores e dimensões usados no aplicativo
R: A)
E: O arquivo Gradle do módulo (geralmente chamado build.gradle (Module: app)) é onde declaramos como o aplicativo deve ser construído. Nele configuramos a versão mínima e de compilação do SDK (minSdkVersion, compileSdkVersion), a versão do aplicativo, e incluímos dependências de bibliotecas (por exemplo, adicionar a dependência do Navigation Component ou do ViewBinding). Em suma, ele controla o processo de compilação e empacotamento. Nos projetos fornecidos, por exemplo, vimos no build.gradle a ativação do ViewBinding e Safe Args via plugins e buildFeatures. As outras opções estão incorretas: B (declaração de componentes) pertence ao AndroidManifest.xml, C (definição de layouts) é feita em XMLs sob res/layout, e D (textos, cores, dimensões) ficam em arquivos XML em res/values, não no Gradle. Portanto, a resposta A é a correta. 

P: Qual opção de código exemplifica corretamente o uso de um Intent explícito para iniciar uma Activity chamada DetalhesActivity a partir da Activity atual?
A) val intent = Intent(this, DetalhesActivity::class.java); startActivity(intent)
B) startActivity(DetalhesActivity)
C) val intent = Intent("DetalhesActivity"); startActivity(intent)
D) DetalhesActivity.launch()
R: A)
E: Para iniciar uma nova Activity de dentro de outra (navegação entre telas usando múltiplas Activities), utiliza-se um Intent explícito especificando a classe de destino. A sintaxe em Kotlin (ou em Java, com sintaxe semelhante) é a mostrada na alternativa A: cria-se um Intent passando o contexto atual (this se estiver dentro de uma Activity, ou por exemplo NomeDaActivityAtual.this em Java) e a classe da Activity de destino (DetallhesActivity::class.java). Em seguida, chama-se startActivity(intent) para efetivamente disparar a nova tela. Essa abordagem foi utilizada, por exemplo, em versões sem o Navigation Component – caso do projeto “Texto Encriptografado I” (se existiu) ou em exemplos simples. As outras alternativas estão incorretas: B não é sintaxe válida; C está tentando usar um Intent implícito mas passando apenas o nome da Activity como string (o que não funciona – Intents implícitos requerem ação/categoria definidas e normalmente não para atividades internas do app); D é fictícia (não existe um método launch() estático assim por padrão). Portanto, a única opção correta é a A. 

P: Qual dessas classes de UI do Android permite exibir facilmente um cronômetro (tempo decorrido crescente) na tela?
A) Chronometer
B) CountDownTimer
C) TimerTask
D) TimePicker
R: A)
E: A classe Chronometer (android.widget.Chronometer) é um componente de interface pronta do Android que exibe um contador de tempo crescente (geralmente formatado como mm:ss) e permite iniciar, pausar e zerar esse contador. No projeto “Cronômetro” fornecido, provavelmente foi usado um Chronometer para mostrar o tempo passando quando o usuário inicia o cronômetro. Já as outras opções não servem para esse propósito específico: B) CountDownTimer é uma classe utilitária para contar regressivamente (de cima para baixo) em segundo plano, não é propriamente um elemento de UI (você teria que atualizar um TextView manualmente com ela); C) TimerTask é uma classe Java para agendar tarefas com Timer, sem relação direta com interface visual; D) TimePicker é um componente de seleção de horário (horas/minutos) pelo usuário, não um cronômetro. Assim, Chronometer é o componente correto para implementar facilmente um cronômetro exibido na tela. 

P: Usando o Navigation Component, em que arquivo ou recurso do projeto definimos os destinos (Fragments/Activities) e as ações de navegação possíveis entre eles?
A) Em um arquivo de gráfico de navegação XML (Nav Graph) dentro do diretório res/navigation (por exemplo, nav_graph.xml)
B) No arquivo AndroidManifest.xml, dentro das tags de <activity> correspondentes
C) No arquivo de layout principal (ex: activity_main.xml) usando atributos especiais de navegação
D) No arquivo strings.xml, listando os nomes das telas e ações
R: A)
E: O Navigation Component utiliza um Navigation Graph (gráfico de navegação), geralmente definido em um arquivo XML colocado em res/navigation. Nesse arquivo, o desenvolvedor adiciona <fragment> para cada destino (tela fragmento) e <action> para indicar transições possíveis entre eles (além de atributos como argumentos de destino). Nos projetos fornecidos, como “Texto Encriptografado II” ou “Bebidas”, um arquivo de navGraph foi configurado definindo as telas (por exemplo, tela de lista de bebidas e tela de detalhes da bebida) e as ações (ex: de lista para detalhes). As outras opções estão incorretas: B o Manifest define componentes globalmente e intenções gerais (como Activities lançáveis ou deep links), mas não detalha as transições do Navigation Component; C o layout pode conter o NavHostFragment para hospedar o navGraph, mas não as definições de destinos; e D strings.xml não tem nenhuma relação com rotas de navegação. Portanto, o local correto é mesmo o arquivo de gráfico de navegação em res/navigation. 

P: No projeto "Sorteador", foi utilizado o método Random().nextInt(11) para gerar um número aleatório. Qual é o possível intervalo de valores retornados por essa chamada?
A) Inteiros de 0 até 10, inclusive o 0 e o 10 (total de 11 valores possíveis)
B) Inteiros de 1 até 11, inclusive
C) Qualquer número inteiro positivo (sem limite máximo)
D) Apenas o número 11, pois 11 é o argumento fornecido
R: A)
E: O método nextInt(int bound) da classe java.util.Random (ou Kotlin Random) gera um número inteiro aleatório entre 0 (inclusive) e bound (exclusivo). Portanto, Random().nextInt(11) pode retornar qualquer inteiro de 0 até 10. Nos materiais, isso foi explicado ao criar o sorteador: se quisermos sortear, por exemplo, um número de 0 a 10 (11 resultados possíveis), passamos 11 como limite. A alternativa A expressa corretamente esse intervalo. A opção B estaria correta se o intervalo fosse 1–11, mas na verdade inclui 0 e vai só até 10, não inclui 11. As opções C e D estão erradas: C confunde sem limite (o limite foi especificado, 11) e D interpreta de forma completamente equivocada (não retorna sempre 11; na verdade 11 nunca sai nesse caso, pois o limite superior é exclusivo). Assim, a saída do sorteio inclui 0 e 10 como extremos, exatamente como dito na alternativa A. 

P: Que atributo devemos usar no layout XML para dar um ID único a um componente de UI e poder referenciá-lo no código (por exemplo, via findViewById ou ViewBinding)?
A) android:id
B) android:label
C) android:name
D) tools:text
R: A)
E: Para atribuir um identificador a um componente em um layout, usamos o atributo android:id. Por exemplo: <TextView android:id="@+id/txtMensagem" ... />. O prefixo @+id/ cria um novo ID chamado txtMensagem. Esse ID será então usado no código Java/Kotlin (via R.id.txtMensagem) para recuperar ou manipular o componente. As outras alternativas referem-se a coisas diferentes: B android:label normalmente é usado no manifest para rotular atividades ou no elemento application para nome do app (não para Views individuais no layout); C android:name pode aparecer em manifest (para nome de Activity, Service etc.) ou em layouts de fragment (para indicar a classe do Fragment a inflar dentro de um FragmentContainerView), mas não define um ID de view; D tools:text é um atributo do Android Studio usado apenas em design para mostrar texto de exemplo no editor (não é aplicado em runtime e não serve como identificador). Portanto, android:id é a resposta correta para identificar views unicamente.
Perguntas de Dificuldade Média

P: Qual a principal diferença entre uma Activity e um Fragment, em termos de uso e ciclo de vida?
A) Uma Activity representa uma tela completa e independente do aplicativo, com ciclo de vida próprio gerenciado pelo sistema, enquanto um Fragment é um componente de interface reutilizável que deve estar dentro de uma Activity, compartilhando o ciclo de vida dela (do momento que é adicionada até ser removida)
B) Fragments rodam em segundo plano e não têm interface de usuário, já Activities sempre têm interface
C) Todo aplicativo Android moderno usa apenas Fragments e não possui Activities reais
D) Um Fragment substitui completamente a necessidade de Activities, pois tem ciclo de vida idêntico e pode existir por si só declarado no manifest
R: A)
E: A alternativa A descreve corretamente: Activity é uma tela inteira, registrada no manifest, que o usuário vê em primeiro plano, enquanto Fragment é um componente menor que deve ser inserido em uma Activity (como parte de sua interface). Fragments têm seu próprio ciclo de vida, mas dependente da Activity hospedeira – por exemplo, eles têm callbacks como onCreateView, onDestroyView além dos análogos de onStart, onPause etc., e quando a Activity é destruída, todos os Fragments dentro dela também são. Nos projetos, vimos Activities servindo de contêiner (ex.: MainActivity) e múltiplos Fragments dentro dela (ex.: Fragmento de entrada de texto e Fragmento de resultado no app de texto encriptografado). A opção B está errada: fragmentos têm interface e rodam dentro da UI da Activity, não em segundo plano. C e D também estão incorretas – embora seja comum o padrão de “single Activity + múltiplos fragments”, as Activities continuam existindo e sendo necessárias (fragmentos não são declarados no manifest nem executados de forma totalmente isolada). Assim, Activity e Fragment têm papéis diferentes e complementares, conforme explicado na opção A. 

P: Em projetos modernos, frequentemente adota-se uma arquitetura de “Single Activity”, onde o app tem praticamente uma única Activity que serve de container para vários Fragments. Qual vantagem esse padrão oferece em comparação a usar múltiplas Activities separadas para cada tela?
A) Facilita a navegação e a passagem de dados entre telas utilizando o Navigation Component, pois elimina a necessidade de criar Intents para cada transição e permite animações e transições de forma unificada dentro de uma mesma Activity
B) Deixa o aplicativo significativamente mais rápido, porque só existe uma Activity ocupando memória independente do número de telas
C) Evita completamente a necessidade de gerenciar ciclo de vida, já que Fragments não possuem ciclo de vida próprio
D) É obrigatório para usar bibliotecas Jetpack – por exemplo, o ViewBinding e o Safe Args só funcionam com uma Activity única
R: A)
E: A arquitetura de single-Activity (uma Activity principal que muda fragmentos) traz vários benefícios de design e manutenção. A principal vantagem está descrita em A: usando uma única Activity com Navigation Component, as trocas de tela acontecem via Fragments, o que simplifica o compartilhamento de dados (podemos usar Safe Args ou ViewModel compartilhada) e padroniza transições (animações de entrada/saída de fragmentos definidas no navGraph) sem precisar declarar cada tela como Activity no manifest ou criar Intents manualmente. Também facilita a consistência de UI (mesma toolbar, por exemplo, controlada centralmente). Nos projetos, o “Bebidas” possivelmente adota esse modelo: MainActivity hospeda o Fragment de lista e o Fragment de detalhes, navegando entre eles. As outras opções estão incorretas ou exageradas: B – o ganho de performance não é significativo simplesmente por ter uma Activity (Fragments também consomem recursos; a escolha é mais por arquitetura do que performance bruta). C – Fragments têm ciclo de vida sim (onAttach, onCreate, onStart, etc.), então o ciclo de vida continua existindo e precisa ser gerenciado, inclusive com cuidado extra pois existem múltiplos componentes na mesma Activity. D – não é obrigatório single-Activity para usar Jetpack; ViewBinding e Safe Args funcionam também com múltiplas Activities (Safe Args pode ser usado para passar dados a Activities via Nav Component e ViewBinding dentro de cada Activity normalmente). Portanto, a opção A resume a verdadeira vantagem do padrão single Activity. 

P: Ao usar o Navigation Component, precisamos adicionar algo no layout da Activity principal para que os Fragments da navegação sejam exibidos. O que deve ser adicionado ao layout da Activity para servir de contêiner da navegação?
A) Um NavHostFragment configurado com o navGraph da aplicação
B) Um FrameLayout vazio, onde os Fragments serão inseridos manualmente via código
C) Um ViewPager ou outro componente de slides para gerenciar os Fragments
D) Não é necessário adicionar nada; o Navigation Component injeta automaticamente uma view contêiner
R: A)
E: Quando utilizamos o Navigation Component, a Activity que vai hospedar os Fragments de navegação precisa ter um NavHostFragment (geralmente no XML do layout da Activity). Este NavHostFragment especial é uma região onde o NavController irá trocar os fragments de acordo com as ações de navegação. Por exemplo, no projeto “Texto Encriptografado II”, o layout da MainActivity provavelmente contém algo assim: <fragment android:id="@+id/nav_host_fragment" android:name="androidx.navigation.fragment.NavHostFragment" app:navGraph="@navigation/nav_graph" .../>. Essa linha indica o contêiner (NavHost) e aponta para qual gráfico de navegação usar. A opção B sugere um FrameLayout manual – antes do Navigation Component, era comum usar FrameLayout e fazer FragmentManager.beginTransaction() manualmente, mas com o Navigation isso não é necessário, substitui-se pelo NavHostFragment. C (ViewPager) é para swipe entre páginas/telas simultâneas (como abas), que não é o caso geral de navegação linear do Navigation Component. D está errada: é preciso sim colocar o NavHostFragment no layout (o sistema não adiciona automaticamente). Portanto, a alternativa A é correta. 

P: Uma das vantagens de utilizar o Safe Args (Navigation Safe Args) para passar dados entre telas é:
A) Ter garantia de segurança de tipo e verificação em tempo de compilação dos argumentos passados, evitando erros de string de chave ou conversão de tipo ao enviar dados entre Fragments/Activities
B) Conseguir enviar dados entre telas sem precisar adicioná-los no gráfico de navegação ou no código (o Safe Args faz tudo automaticamente)
C) Aumentar a performance da comunicação entre componentes, deixando a passagem de dados mais rápida que métodos tradicionais
D) Permitir passar dados apenas por meio de Intents implícitos, melhorando a segurança do app
R: A)
E: O Safe Args gera classes e métodos específicos para cada ação de navegação com argumentos definidos, garantindo que: se um Fragment espera, por exemplo, um inteiro “pontuação”, o código gerado (ex: SomeFragmentDirections.actionXtoY(pontuacao: Int)) exige um Int em tempo de compilação. Isso evita erros comuns de passar uma string chave errada ou um tipo errado num Bundle. Nos projetos fornecidos, isso foi enfatizado: por exemplo, no “Texto Encriptografado II”, ao navegar do fragmento de entrada para o fragmento de resultado, Safe Args garantiu que a string do texto a ser criptografado fosse passada corretamente, sem risco de esquecer alguma coisa ou errar o nome do parâmetro. A opção B está errada porque precisamos sim configurar os argumentos no navGraph e usar as classes geradas no código – o Safe Args facilita, mas não é mágico a ponto de deduzir dados sem configuração. C não procede – Safe Args foca em segurança e conveniência, não em melhoria perceptível de performance de passagem de dados (a comunicação subjacente continua usando Bundles, o overhead é semelhante). D está fora de contexto – Safe Args é para Navigation Component (principalmente Fragments), não tem relação com Intents implícitos e segurança no sentido de permissionamento de componentes. Portanto, a alternativa A explica corretamente a vantagem principal. 

P: Para usar o Safe Args no projeto Android (Navigation Safe Args Plugin), qual passo de configuração é necessário?
A) Adicionar o plugin do Safe Args tanto no Gradle de nível de projeto (classpath) quanto aplicar o plugin no Gradle do módulo app, habilitando assim a geração das classes de navegação
B) Marcar uma opção “Enable SafeArgs” nas configurações do Android Studio ao criar o projeto
C) Ativar as Safe Args no AndroidManifest.xml dentro da tag application
D) Nenhum passo extra – o Safe Args já vem habilitado por padrão em todos os projetos AndroidX
R: A)
E: O Safe Args requer configuração explícita: precisamos incluir o plugin de navegação Safe Args. Isso envolve editar dois arquivos Gradle: no build.gradle (Project) adicionar a dependência classpath do plugin Safe Args (por exemplo, 'androidx.navigation:navigation-safe-args-gradle-plugin:VERSÃO' dentro de buildscript->dependencies), e no build.gradle (Module: app) aplicar o plugin (por exemplo, apply plugin: "androidx.navigation.safeargs.kotlin" se usando Kotlin, ou .safeargs para Java). Nos materiais fornecidos, há orientações nesse sentido, pois sem esses passos o projeto não gerará as classes Directions e Args. A alternativa B está incorreta – não existe uma caixa de seleção mágica que liga Safe Args depois do projeto criado; há um checkbox “Use Safe Args” apenas em alguns templates, mas internamente ele faz justamente a configuração de Gradle. C é falsa, pois o manifest não tem entrada para Safe Args. D também é falsa – embora projetos modernos usem AndroidX, Safe Args não está ativo por padrão, é opcional adicionar. Portanto, a resposta correta é a A, que detalha os passos reais para habilitar o Safe Args. 

P: Como habilitar o ViewBinding em um projeto Android Studio existente?
A) Editando o arquivo build.gradle (módulo app) para ativar o ViewBinding, por exemplo adicionando dentro de android { ... } a seção buildFeatures { viewBinding true } e sincronizando o projeto
B) Marcando todas as Views no layout XML com um atributo bindable para que o ViewBinding identifique
C) Instalando uma biblioteca separada de ViewBinding via dependência Maven/Gradle
D) Não é necessário habilitar – o ViewBinding já vem ativo em todos os projetos padrão
R: A)
E: Para usar ViewBinding, devemos habilitá-lo explicitamente no Gradle do módulo. A opção correta A descreve isso: dentro do bloco android {} do build.gradle do app, insere-se buildFeatures { viewBinding = true }. Após sincronizar o Gradle, o Android Studio passará a gerar as classes de binding (por exemplo, ActivityMainBinding correspondendo ao layout activity_main.xml). Nos projetos fornecidos, vemos essa configuração habilitada – assim, no código pôde-se substituir findViewById pelo uso das classes de binding. A opção B está incorreta: não se marca cada View no XML (isso seria mais relacionado a DataBinding, que tem expressões no XML, mas não ao ViewBinding). C também está errada – o ViewBinding faz parte do Android Gradle Plugin, não é uma dependência externa que se instala via Maven central, apenas ativamos a feature. D é falsa: projetos não vêm com ViewBinding ativo automaticamente (a não ser que você marque a opção ao criar o projeto). Então a alternativa A é a correta. 

P: Suponha que o ViewBinding esteja habilitado no projeto. Qual das opções abaixo mostra a forma correta de acessar um TextView de id txtResultado definido no layout activity_main.xml, dentro da Activity correspondente, usando ViewBinding?
A) binding.txtResultado.text = "Texto exibido"
B) findViewById<TextView>(R.id.txtResultado).text = "Texto exibido"
C) this.txtResultado.setText("Texto exibido")
D) R.id.txtResultado.text = "Texto exibido"
R: A)
E: Com ViewBinding ativo, ao inflar o layout através do binding (por exemplo, val binding = ActivityMainBinding.inflate(layoutInflater) e passando binding.root para setContentView), a classe de binding gerada (ActivityMainBinding) possui propriedades correspondentes a cada View com id no layout. Assim, podemos acessar diretamente binding.txtResultado que já é um TextView tipado. A opção A demonstra isso e é exatamente como foi empregado nos projetos que usam ViewBinding (por exemplo, no projeto “Bebidas”, deve ter havido código parecido para acessar componentes da interface sem findViewById). A opção B mostra a abordagem antiga usando findViewById – embora funcional, ela não aproveita o ViewBinding (além de exigir cast explícito em Java, ou genérico em Kotlin). C é inválida – this.txtResultado não existe, a Activity não contém um campo com o nome do id a menos que se use synthetic binding do Kotlin (que está depreciado). D tenta acessar o id diretamente, o que é incorreto (R.id.txtResultado é só um int, não tem propriedade text). Portanto, a maneira correta com ViewBinding é a fornecida em A. 

P: Considere a função abaixo, presente no projeto "Texto Encriptografado II", que realiza a cifragem de uma string deslocando cada caractere em +1 no código Unicode:
kotlin
Copiar
Editar
fun cifrarTexto(texto: String): String {
    var resultado = ""
    for (ch in texto) {
        resultado += (ch.code + 1).toChar()
    }
    return resultado
}
Se o usuário inserir o texto "ABC", qual será o resultado exibido após a cifragem?
A) "BCD"
B) "ABC1"
C) "ABD"
D) "DEF"
R: A)
E: A função demonstrada realiza uma cifragem muito simples: para cada caractere da string de entrada, obtém seu código numérico (ch.code) e soma 1, convertendo de volta em caractere. Ou seja, desloca cada letra uma posição para frente na tabela Unicode (no caso de letras maiúsculas do alfabeto latino, desloca para a próxima letra). Aplicando em "ABC": 'A' vira 'B', 'B' vira 'C', 'C' vira 'D'. O resultado concatenado é "BCD". Essa lógica reflete um exemplo de criptografia didática usado no projeto (basicamente um César de deslocamento 1). A alternativa A está correta com "BCD". As outras estão incorretas: B "ABC1" não faz sentido aqui (sugere talvez que adicionou um caractere '1' no fim, o que não ocorre nessa função), C "ABD" indica um erro apenas no último caractere (o que não condiz com a regra consistente de deslocar todos), e D "DEF" seria o resultado se o deslocamento fosse de +3 (ou se interpretássemos cada letra avançando 3 posições: A->D, B->E, C->F), mas no código dado o incremento é de 1, não 3. Portanto, "BCD" é claramente a saída correta. Esta lógica foi usada no app para encriptar o texto digitado, e no app original o usuário provavelmente veria o texto cifrado exibido, confirmando esse resultado para entradas simples. 

P: Ao fechar uma Activity (por exemplo, o usuário pressionando o botão Voltar do dispositivo), qual é a sequência padrão de métodos do ciclo de vida da Activity que será executada?
A) onPause -> onStop -> onDestroy
B) onPause -> onDestroy -> onStop
C) onSaveInstanceState -> onPause -> onDestroy
D) onStop -> onDestroy -> onPause
R: A)
E: Quando uma Activity é finalizada (seja o usuário saindo da tela ou a Activity sendo terminada pelo sistema), o ciclo de vida acontece nesta ordem: primeiro onPause() (a Activity perde o foco, outra tela está tomando o primeiro plano), depois onStop() (a Activity deixa de ser visível), e por fim onDestroy() (a Activity está sendo destruída e liberada da memória). Essa ordem foi apresentada nas aulas e materiais – é importante para liberar recursos nos momentos certos. A opção A traz exatamente essa sequência. A ordem das demais está incorreta: B troca onStop e onDestroy – na verdade onDestroy é chamado por último; C intercala onSaveInstanceState, mas note que onSaveInstanceState nem sempre é chamado nesse fluxo a menos que haja uma configuração (ele é chamado antes de onStop em caso de mudança de configuração ou quando o sistema precisa salvar estado, mas não é garantido em um simples “voltar” que destrói a Activity, então não é normalmente listado na sequência de encerramento padrão documentada); D está totalmente fora de ordem lógica. Assim, a resposta A reflete o comportamento correto. Por exemplo, no projeto “Cronômetro”, se o usuário sai da tela do cronômetro, onPause e onStop da Activity do cronômetro são chamados – e é ali que deveríamos parar o cronômetro para não tocar em segundo plano, antes de onDestroy. 

P: Para exibir uma lista potencialmente grande de itens com rolagem (scroll) de forma eficiente, reutilizando componentes de item de lista, qual componente do Android é mais indicado?
A) RecyclerView
B) ListView
C) Uma coluna de vários TextViews dentro de um ScrollView
D) TableLayout preenchido dinamicamente
R: A)
E: O RecyclerView (disponível em androidx.recyclerview.widget.RecyclerView) é atualmente a solução recomendada para listas eficientes. Ele recicla as views dos itens que saem da tela para exibir novos itens (padrão ViewHolder), tornando o uso de memória e a performance muito melhores em listas longas. No projeto “Bebidas”, se tivermos uma lista de bebidas, usar RecyclerView seria ideal para exibir os itens (possivelmente com um Adapter customizado). ListView (B) era usado antigamente e também reaproveita algumas views, mas tem menos flexibilidade e ficou obsoleto em favor do RecyclerView. A opção C (um monte de TextViews dentro de um ScrollView) seria extremamente ineficiente para muitos itens, pois todas as views seriam criadas de uma vez (sem reciclagem) e o desempenho sofreria com listas grandes. A opção D (TableLayout) não é adequada para listas não tabulares e igualmente exigiria criar todas linhas manualmente. Portanto, a alternativa A é correta. Observação: ListView (B) era a solução clássica, porém a pergunta enfatiza “de forma eficiente” – o RecyclerView provê melhores otimizações e recursos extras, por isso é a escolha mais indicada hoje. 

P: Dentro do ciclo de vida de um Fragment, qual método é responsável por inflar o layout XML e retornar a View da interface para ser exibida?
A) onCreateView
B) onCreate
C) onStart
D) onViewCreated
R: A)
E: Em um Fragment, o método onCreateView(LayoutInflater, ViewGroup?, Bundle?) é chamado pelo sistema quando é hora do fragmento montar sua interface. É ali que chamamos algo como inflater.inflate(R.layout.nome_do_layout, container, false) para obter a View do layout e retornamos essa View. Por exemplo, no projeto de texto encriptografado II, o fragmento de resultado provavelmente sobrescreve onCreateView para inflar seu layout de resultado. A alternativa D (onViewCreated) ocorre logo após onCreateView – nele a View já foi inflada e podemos iniciar configurações adicionais, mas a inflação em si ocorre em onCreateView. B (onCreate) no Fragment é chamado antes, mas nele geralmente não se acessa UI (pois não existe ainda); C (onStart) acontece depois que a view já foi criada e o fragment está prestes a ficar visível. Então, o método central para inflar a interface de um Fragment é onCreateView, resposta A. 

P: No uso do Navigation Component, qual objeto controlador usamos no código para efetivamente comandar a navegação entre Fragmentos?
A) Um NavController – por exemplo obtido via findNavController() no Fragment atual
B) O FragmentManager diretamente, chamando beginTransaction() e replace() para cada navegação
C) Uma instância da classe gerada do gráfico de navegação (ex: NavGraphDirections) utilizada como substituta de Intent
D) O DrawerLayout ou outro layout de navegação automaticamente gerencia isso, não precisamos de objeto extra
R: A)
E: Com Navigation Component, usamos o NavController para acionar as navegações definidas no nav_graph. No código de um Fragment, tipicamente chamamos findNavController().navigate(direcaoOuId) para ir de um destino a outro. Esse NavController é justamente o objeto responsável por gerenciar a troca de Fragments no NavHostFragment e o back stack de navegação. Nos projetos, vimos chamadas desse tipo, por exemplo, no fragmento inicial do “Texto Encriptografado II” deve ter algo como findNavController().navigate(R.id.action_inputFragment_to_resultFragment, bundle) ou usando Safe Args navigate(InputFragmentDirections.actionInputToResult(texto)). A alternativa B descreve a abordagem manual (FragmentManager.beginTransaction), que não é necessária ao usar NavController – o Navigation Component abstrai essas operações. C confunde conceitos: NavGraphDirections não existe exatamente; existem classes Directions geradas para ações específicas, mas ainda precisamos de um NavController para executar navigate. D não procede – DrawerLayout é um componente de UI (menu lateral) e não gerencia navegação por conta própria. Assim, a opção A é a correta: usamos NavController (obtido geralmente por findNavController ou por NavigationUI helper em Activities) para navegar entre os destinos. 

P: Podemos associar uma função de clique de botão diretamente no XML do layout usando um atributo que referencia um método público da Activity. Qual é esse atributo XML?
A) android:onClick
B) tools:onClick
C) app:actionOnClick
D) android:clickable
R: A)
E: O atributo android:onClick="nomeDoMetodo" pode ser usado em um botão (ou outra View clicável) no layout XML para vincular o clique a um método de mesmo nome na Activity. Por exemplo, <Button android:text="Enviar" android:onClick="enviarMensagem" .../> indica que, na Activity associada a esse layout, deve existir um método público fun enviarMensagem(view: View) { ... }. Quando o botão for clicado, o Android chamará esse método automaticamente. Essa técnica foi mencionada possivelmente como alternativa ao uso de setOnClickListener em código. As outras opções estão erradas: tools:onClick existiria apenas para propósitos de design preview e não tem efeito em tempo de execução (qualquer atributo no namespace tools não vai para o app final). app:actionOnClick não existe. android:clickable é um atributo booleano que apenas indica se a view é clicável ou não, mas não associa ação de clique; portanto não serve para linkar com método. Logo, a opção A) é correta. 

P: Se temos um campo de texto EditText chamado edtNome onde o usuário digita o nome, qual é a forma correta de obter o texto inserido nesse EditText via código?
A) val nome = edtNome.text.toString()
B) val nome = edtNome.getText() (sem conversão)
C) val nome = edtNome.value
D) val nome = R.string.edtNome
R: A)
E: Para pegar o texto de um EditText, utilizamos a propriedade .text, que retorna um Editable (no contexto Kotlin) ou chamamos getText() no objeto EditText (em Java). Como .text ou getText() não retornam exatamente uma String pura (mas sim um Editable), é recomendável chamar .toString() para converter em String padrão. Assim, a linha edtNome.text.toString() nos dá o conteúdo que o usuário digitou. Essa boa prática aparece nos projetos ao ler entradas do usuário, por exemplo, antes de cifrar o texto no projeto de texto encriptografado, algo como val entrada = editTextMensagem.text.toString(). A alternativa B (getText sem toString) retornaria um Editable; embora em Kotlin possamos às vezes usar diretamente em uma string, geralmente precisamos de toString para evitar problemas ou comparações inesperadas. Em Java seria necessário definitivamente toString ou usar métodos do Editable. C value não é uma propriedade de EditText – não existe edtNome.value. D R.string.edtNome refere-se a um recurso de string (provavelmente nem existe um com esse nome, e mesmo se existisse não traria o conteúdo digitado pelo usuário, apenas um valor fixo). Portanto, a opção A é a correta e demonstra a obtenção adequada da entrada do EditText. 

P: Por que não devemos realizar operações muito pesadas (como acessos de rede ou cálculos intensivos) na thread principal (UI thread) de um aplicativo Android?
A) Porque isso pode travar a interface do usuário, tornando o app não responsivo e até disparar um erro ANR (Application Not Responding) se a thread principal ficar bloqueada por muito tempo
B) Porque a thread principal tem prioridade muito baixa no sistema, então as operações seriam extremamente lentas se feitas nela
C) Porque a thread principal reinicia a cada 5 segundos, podendo interromper a operação se ela for pesada
D) Porque essas operações sempre falham na thread principal devido a restrições do Android, exigindo o uso de AsyncTask ou Threads separadas
R: A)
E: A thread principal (UI thread) é responsável por desenhar a interface e responder às interações do usuário. Se fizermos algo demorado nela – por exemplo, baixar um arquivo grande da internet ou processar criptografia pesada – a interface “congela” enquanto esse processamento não termina, pois a thread não consegue ao mesmo tempo atualizar a UI. Se o bloqueio exceder alguns segundos, o sistema detecta e mostra um diálogo de ANR (App não respondendo), e o usuário pode forçar o fechamento do app. Os materiais do curso enfatizam isso: por exemplo, se no projeto “Cronômetro” decidíssemos carregar um dado extenso do banco de dados no onCreate, sem thread separada, veríamos lentidão ao abrir a tela. A opção A explica corretamente esse problema. As outras opções estão incorretas: B é falsa – a thread principal na verdade tem alta prioridade, e justamente por isso travar ela é crítico. C não faz sentido (a UI thread não reinicia periodicamente; ela existe enquanto a Activity/looper do app existe). D – não é que sempre falhem, mas operações de rede, por exemplo, geram exceção se feitas na UI thread (por política do Android a partir do Honeycomb), porém o principal motivo é mesmo manter a responsividade. Em suma, devemos usar Threads separadas, AsyncTasks (nas versões mais antigas) ou corrotinas, WorkManager etc., para tarefas pesadas, mantendo a UI thread livre. 

P: Como o Android sabe qual Activity abrir primeiro quando o aplicativo é iniciado (ou seja, qual é a tela “principal/launcher” do app)?
A) A Activity que possui um <intent-filter> no AndroidManifest.xml com ação MAIN e categoria LAUNCHER será tratada como ponto de entrada (launcher) do aplicativo
B) É sempre a Activity chamada “MainActivity” por convenção
C) É a primeira Activity listada no arquivo AndroidManifest.xml, independente de filtros
D) Isso é definido no arquivo build.gradle, na seção de defaultConfig
R: A)
E: No AndroidManifest, dentro da declaração de uma Activity, colocamos um <intent-filter> especial para indicar que aquela Activity deve aparecer no launcher do dispositivo. Ele tipicamente contém: <action android:name="android.intent.action.MAIN" /> e <category android:name="android.intent.category.LAUNCHER" />. Somente a Activity com esses filtros será mostrada como o ícone do app e iniciada quando o usuário toca no ícone. Nos projetos, a Activity principal (como MainActivity) está assim definida no manifest – você pode verificar que o manifest do projeto “Sorteador” ou “Bebidas” marca a tela inicial dessa forma. As outras opções estão erradas: B – não é pelo nome; por convenção muitos nomeiam MainActivity, mas o que vale é o filter no manifest. C – a ordem no Manifest não determina quem é launcher, precisa do filtro; D – o build.gradle não define isso. Portanto, a alternativa A descreve corretamente o mecanismo. 

P: Sobre o Safe Args, qual das afirmações é verdadeira a respeito do tipo de dados que ele pode passar entre destinos?
A) Safe Args permite passar objetos complexos entre Fragments/Activities, desde que esses objetos implementem Serializable ou Parcelable, além dos tipos primitivos e Strings suportados nativamente
B) Safe Args limita-se a passar apenas tipos básicos (int, float, boolean, String) – não suporta passar objetos ou listas
C) O Safe Args converte qualquer objeto automaticamente em JSON para enviá-lo e reconverte ao receber, sem necessidade de interfaces especiais
D) Para usar Safe Args, não é necessário definir os tipos dos argumentos em lugar nenhum; eles são deduzidos em tempo de execução
R: A)
E: O Safe Args suporta, além de tipos primitivos, Strings e classes do SDK (por exemplo, Parcelable classes como Bundle), também objetos personalizados, desde que esses objetos sejam serializáveis ou parceláveis (tipicamente implementando Parcelable para eficiência). Por exemplo, se no projeto “Bebidas” quiséssemos passar um objeto Bebida (contendo nome, descrição, etc) de um fragmento de lista para outro de detalhes, poderíamos fazê-lo marcando esse objeto como Parcelable. Safe Args geraria um método navigate ou uma classe Directions que aceita diretamente um objeto Bebida, e cuidaria de serializá-lo para Bundle. A opção A reflete esse fato. A opção B está errada – Safe Args não se limita a tipos básicos; pode lidar com objetos parcelables e até arrays/listas (de tipos suportados). C também está incorreta – Safe Args não usa JSON; ele utiliza Parcelable/Serializable do Android, não convertendo para texto. D está errada, pois é necessário sim declarar cada argumento e seu tipo no nav_graph.xml para Safe Args gerar as classes adequadas. Em suma, Safe Args é bastante flexível com tipos de dados, e a alternativa A traz a condição necessária para objetos complexos (implementarem Serializable/Parcelable). 

P: Por que as Activities dos apps geralmente estendem AppCompatActivity (da biblioteca de suporte AndroidX) em vez de extender diretamente android.app.Activity?
A) Porque AppCompatActivity fornece compatibilidade retroativa com versões antigas do Android e suporte a funcionalidades modernas (como ActionBar/Barras de título personalizáveis via ToolBar) através das bibliotecas de suporte (Jetpack). Ela encapsula comportamentos do ciclo de vida e integrações com Fragments, fazendo a Activity funcionar de forma consistente em diferentes versões do Android
B) Porque Activity (da API padrão) foi depreciada e não funciona nas versões novas do Android
C) Porque AppCompatActivity é exigida para qualquer projeto que use Navigation Component ou ViewBinding
D) Não há diferença real – AppCompatActivity é apenas um alias com nome diferente, por questões de organização do Android Studio
R: A)
E: AppCompatActivity é parte da biblioteca de suporte (AndroidX AppCompat) e é a base recomendada para Activities, sobretudo para manter compatibilidade e acesso a recursos das ActionBar/ToolBar, temas Material Components, e integração mais fácil com Fragments. Estender AppCompatActivity garante que mesmo em dispositivos com versões mais antigas (suportados pelo minSdk do app) você terá comportamento consistente, pois a biblioteca implementa internamente o que faltar. Nos nossos projetos, as classes estavam definidas como, por exemplo, class MainActivity : AppCompatActivity(), evidenciando esse uso. A opção A explica bem isso. A opção B está errada: a classe Activity base não está depreciada, apenas não inclui as melhorias de compatibilidade. C está incorreta – embora usar Navigation ou ViewBinding geralmente implique já estar usando AppCompatActivity, não é uma “exigência técnica” dessas libs (ViewBinding funciona com ComponentActivity também, e Navigation pode usar FragmentActivity; mas no template padrão escolhe-se AppCompatActivity pela razão da compat). D também é falsa; há diferenças significativas de funcionalidade. Portanto, a justificativa real é a da alternativa A. 

P: Em um Fragment de destino, como podemos recuperar um argumento inteiro chamado "quantidade" que foi passado via Safe Args a partir de outro Fragment?
A) Utilizando a classe gerada correspondente aos argumentos do Fragment: por exemplo, chamando val args = DestinoFragmentArgs.fromBundle(requireArguments()) e então acessando val qtd = args.quantidade
B) Chamando diretamente um método estático do fragment de destino, por exemplo DestinoFragment.getQuantidade()
C) Usando um Bundle manual: val qtd = fragment.arguments!!.getInt("quantidade"), ignorando as classes geradas do Safe Args
D) Armazenando o valor em uma variável global ou ViewModel compartilhado, já que Safe Args não permite recuperar diretamente
R: A)
E: Ao utilizar Safe Args, para um Fragment que recebe argumentos, é gerada uma classe NomeDoFragmentoArgs com propriedades correspondentes. A forma típica de obter esses valores no Fragment destino é usar o método fromBundle passando o bundle de argumentos (obtenível via requireArguments() ou arguments). Por exemplo, se no nav_graph o Fragment destino "DetalheFragment" tem um argumento "quantidade", será gerada a classe DetalheFragmentArgs com um método fromBundle() que retorna um objeto contendo o campo quantidade. Em Kotlin, também é comum usar o delegate by navArgs<DetalheFragmentArgs>() para simplificar, mas internamente é a mesma ideia. Nos projetos, vimos esse padrão: no fragment de resultado do texto encriptografado, algo como val args: ResultadoFragmentArgs by navArgs(); args.textoClaro para pegar o texto a exibir. A opção A mostra corretamente o uso via fromBundle. A alternativa B não existe – não há um método estático auto-criado assim no fragment. C é uma forma alternativa sem Safe Args (acessar Bundle manualmente), que até funciona, mas a pergunta sugere uso do Safe Args; e ao usar Safe Args preferimos a classe gerada (ela internamente faz essentially isso com segurança de tipo). D também não procede: embora ViewModels ou variáveis globais possam compartilhar dados, não é o método relacionado ao Safe Args em si. Em resumo, a forma correta com Safe Args é a apresentada em A. 

P: Qual a diferença entre um Intent implícito e um Intent explícito no Android?
A) Um Intent explícito especifica diretamente o componente de destino pelo nome/classe (por exemplo, Intent(this, OutraActivity::class.java)), enquanto um Intent implícito não cita um componente específico, mas sim uma ação geral a ser realizada (por exemplo, "ACTION_SEND" para compartilhar, "ACTION_VIEW" para abrir um link), permitindo que outras aplicações ou componentes adequados atendam a essa solicitação
B) Intent implícito é utilizado apenas para iniciar Services, enquanto Intent explícito serve para Activities e Broadcasts
C) Intents explícitos carregam extras (dados) e Intents implícitos não podem carregar dados extras
D) Não há diferença – são apenas dois nomes para o mesmo conceito de intenção de executar algo
R: A)
E: A distinção entre Intent explícito e implícito é importante. Intents explícitos são usados dentro do próprio aplicativo quando você sabe exatamente qual Activity/Service deseja chamar – você especifica a classe de destino. Por exemplo, no projeto foi utilizado um Intent explícito para abrir DetalhesActivity a partir de MainActivity (indicando diretamente a classe DetalhesActivity). Já Intents implícitos descrevem uma ação a ser realizada sem citar quem exatamente fará; o sistema Android então procura um componente (de qualquer app instalado) que possa lidar com aquela ação. Por exemplo, se no app “Bebidas” tivesse um botão "Visitar site da bebida", você poderia usar um Intent implícito com ACTION_VIEW e uma URL; isso faria o Android procurar um navegador para abrir o link. A alternativa A explica isso corretamente. A opção B está errada – Intents implícitos também podem iniciar Activities (ex: compartilhar texto abre apps de compartilhamento) e Broadcasts também usam intents (mas broadcast intents são um caso à parte). C está incorreta, pois ambos tipos de Intent podem carregar dados extras (você pode colocar extras em intents implícitos também, por exemplo um ACTION_SEND pode levar um EXTRA_TEXT). D é falsa – existe diferença clara e a API as trata distintamente no processo de resolução. Portanto, a resposta A fornece a explicação correta.

P: Em um Fragment, por que é recomendável definir a variável de ViewBinding do Fragment como nula no método onDestroyView()?
A) Para evitar vazamento de memória (memory leak), liberando a referência à View do Fragment no momento em que ela é destruída. Como a vida da View de um Fragment é delimitada entre onCreateView e onDestroyView, manter o binding (que referencia Views) além disso poderia impedir a coleta de lixo dessas Views se o Fragment permanecer em memória
B) Porque assim o Fragment pode reutilizar o mesmo objeto de binding na próxima vez que a View for criada, evitando recriação de instâncias
C) Porque o binding deixa de ser válido após onPause, e marcá-lo como nulo em onDestroyView impede exceções de uso incorreto
D) Não é necessário fazer isso; o Android libera automaticamente todos os recursos de UI quando o Fragment é destruído
R: A)
E: Quando usamos ViewBinding em Fragments, a boa prática (conforme documentado) é anular o binding em onDestroyView(). Isso acontece porque o Fragment pode permanecer em memória após sua view ser destruída (por exemplo, se o Fragment for colocado em back stack, sua instância permanece). O binding, por sua natureza, contém referências diretas às Views do layout. Se não for limpo, o Fragment manterá essas referências na memória mesmo depois que as Views foram destruídas, causando vazamento de memória. Nas aulas/projetos, foi enfatizado este cuidado: “limpar” o binding = null em onDestroyView. A opção A explica exatamente esse motivo. B está incorreta – não reutilizamos o mesmo objeto de binding em uma nova criação; na próxima criação de view, um binding novo será obtido inflando novamente. C mistura conceitos: o binding não “deixa de ser válido após onPause” (o correto é após onDestroyView), e o principal é liberar recursos, não evitar exceção (embora acessar binding depois da view destruída cause erro, daí fazer =null ajuda a acusar acesso indevido). D está errada porque, embora o Android libere a maioria dos recursos eventualmente, a referência em uma variável no Fragment poderia adiar a liberação das Views pelo garbage collector. Portanto, a alternativa A é correta e demonstra entendimento de gerenciamento de memória com Fragments e ViewBinding. 

P: Um desenvolvedor colocou a chamada findViewById(R.id.txtValor) dentro do método onCreate() de um Fragment e recebeu null como resultado (mesmo o componente existindo no layout do Fragment). Qual é a causa mais provável desse problema?
A) O método onCreate() do Fragment é chamado antes da criação da interface (View), ou seja, antes de onCreateView. Portanto, chamar findViewById nesse momento não encontra nada, pois a View raiz do Fragment ainda não foi inflada. A busca por ID deve ser feita após a View existir – tipicamente em onCreateView (usando view.findViewById) ou em onViewCreated
B) O ID txtValor não foi declarado no arquivo de layout correspondente ao Fragment, causando findViewById retornar null
C) Em Fragments deve-se usar sempre requireActivity().findViewById em vez de findViewById simples; caso contrário, retorna null
D) O Fragment não estava anexado à Activity no momento do onCreate, então nenhum recurso pode ser acessado
R: A)
E: Em um Fragment, o onCreate() é chamado antes da criação da interface gráfica. Diferente de uma Activity (onde após setContentView você pode usar findViewById), no Fragment você só tem a View do layout disponível após onCreateView retorna a View inflada. Assim, se tentar findViewById dentro de onCreate (que é muito cedo), obterá null. A prática correta é: inflar o layout em onCreateView e então ou retornar a View diretamente (e configurar nela se preciso) ou usar onViewCreated, que recebe a View inflada, para setar componentes. Por exemplo, nos projetos, qualquer acesso a Views dentro de fragmentos foi feito após inflater o layout – quem usou ViewBinding provavelmente evitou esse erro, mas é um erro comum quando se usa findViewById manualmente. A alternativa A explica perfeitamente a causa. B poderia ser uma possibilidade genérica (um ID errado retornaria null), mas no caso da pergunta o ID existe sim no layout – o sintoma descrito (null no onCreate) bate com a questão de timing de vida. C está incorreta – você só usaria requireActivity().findViewById para buscar algo na Activity, não dentro do próprio Fragment; além disso, isso não resolve se a view do Fragment não existe ainda. D não é precisa – o fragment não anexo impediria acesso a contexto, mas aqui o ponto é o momento da criação da view, não o attach em si (e onCreate do Fragment já está com fragment anexado). Portanto, a causa é o momento incorreto da chamada, como descrito na opção A. 

P: Suponha que o Fragment A navegue para o Fragment B usando o Navigation Component, e o Fragment A seja colocado na pilha de back stack. O que acontece com o Fragment A em termos de ciclo de vida quando o Fragment B é exibido em primeiro plano?
A) O Fragment A terá seus métodos onPause() e onStop() chamados e sua View será destruída (onDestroyView()), porém a instância do Fragment A em si permanece viva na back stack (onDestroy() não é chamado nesse momento). Assim, quando o usuário voltar, o Fragment A poderá recriar sua View em onCreateView novamente
B) O Fragment A permanece ativo e visível por baixo do Fragment B, apenas perde o foco de interação
C) O Fragment A é completamente destruído, chamando onPause, onStop e onDestroy (todo o ciclo) assim que B entra em cena, tendo que ser recriado do zero se o usuário voltar
D) O Fragment A não sofre nenhuma mudança de ciclo de vida ao abrir B – ele continua em onResume, apenas escondido visualmente
R: A)
E: Pelo funcionamento do Navigation Component (e Fragments em geral com back stack), quando navegamos de A para B e adicionamos A ao back stack, o Fragment A sai da tela: ele primeiro chama onPause() (perde foco), depois onStop() (ficou completamente oculto). O framework também chama onDestroyView() em A, destruindo a hierarquia de Views de A para liberar memória, já que a UI de A não está visível. No entanto, o objeto Fragment A ainda existe em memória guardado na back stack, e não recebe onDestroy() – ou seja, seu estado não volátil é mantido (por exemplo, variáveis do Fragment, ou valores salvos no Bundle de estado). Quando o usuário pressiona "voltar", o Fragment B é destruído e o Fragment A é retomado: ele chamará onCreateView de novo para recriar a interface, onStart, onResume e volta à tela. A opção A descreve corretamente essa sequência. A alternativa B está incorreta – A não fica visível atrás de B; Fragments substituem uns aos outros no NavHost, então A fica oculto (Stop) e a UI de A é removida. C também está incorreta – onDestroy de A não ocorre ao navegar para B (a não ser que especificamente não se tenha adicionado ao back stack, mas no contexto de Navigation presume-se que sim por padrão). D está errada pois contradiz o ciclo real: A definitivamente sai do estado de onResume ao navegar para B. Portanto, a resposta A está correta. Esse comportamento foi visto nos projetos: por exemplo, ao abrir o fragmento de detalhes de uma bebida, o fragmento de lista entra em onStop e libera sua view; se voltarmos, ele recria a lista. 

P: Para preservar o estado de uma Activity (por exemplo, um valor sorteado ou o tempo de um cronômetro) durante uma rotação de tela, qual abordagem deve ser usada?
A) Implementar onSaveInstanceState na Activity, salvando os dados importantes em um Bundle, e restaurá-los posteriormente (no onCreate ou onRestoreInstanceState) quando a Activity for recriada após a rotação
B) Definir android:configChanges="orientation" no AndroidManifest para a Activity, para evitar que ela seja reiniciada em rotações e assim manter os valores automaticamente
C) Armazenar os valores em variáveis static (globais) ou em uma classe Singleton, assim eles persistem após a destruição da Activity
D) Não há como preservar automaticamente – deve-se solicitar que o usuário insira novamente os dados após rotacionar
R: A)
E: A maneira canônica de salvar estado frente a mudanças de configuração (como rotação) é usar o mecanismo de salvamento de estado da Activity. Antes da Activity ser destruída pela rotação, o sistema chama onSaveInstanceState(Bundle), onde o desenvolvedor pode colocar dados (ex: outState.putInt("numeroSorteado", numero) ou outState.putLong("tempo", valorDoCronometro)). Quando a Activity é recriada, esse Bundle é passado para onCreate e onRestoreInstanceState, permitindo recuperar os valores e restaurar a UI ao estado anterior. Por exemplo, no projeto “Sorteador”, poderia-se salvar o número sorteado atual para reapresentá-lo após rotacionar em vez de resetar. Ou no “Cronômetro”, salvar o tempo decorrido para continuar de onde parou. A alternativa A está correta e segue as recomendações do Android. A opção B (manipular configChanges manualmente) até impede a recriação, mas é considerada um truque não recomendado na maioria dos casos, pois o desenvolvedor teria que lidar manualmente com vários aspectos (e isso quebra suporte a recursos como múltiplos layouts em orientações). C – usar static singletons pode ocasionar leaks ou valores residuais incorretos, não é o método padrão documentado (embora em alguns casos ViewModel ou singleton possam manter estado, a abordagem oficial para pequenos estados de UI é onSaveInstanceState). D obviamente está errada – o Android provê mecanismos para evitar perda de dados do usuário. Assim, a abordagem A é a esperada. 

P: Qual método do ciclo de vida existe nos Fragments e não existe nas Activities?
A) onCreateView()
B) onResume()
C) onPause()
D) onDestroy()
R: A)
E: Fragments introduzem alguns callbacks específicos que Activities não possuem, devido ao fato de Fragments gerenciarem sua própria interface dentro de uma Activity. O mais característico é o onCreateView(), que é único de Fragments. Nele o Fragment infla e configura sua interface visual. Nenhuma Activity tem onCreateView – Activities carregam layout usando setContentView em onCreate. Outros métodos exclusivos de Fragment incluem onAttach, onViewCreated, onDestroyView, onDetach, etc. A opção A lista um desses, onCreateView, que de fato não existe em Activity. B, C e D estão presentes tanto em Activities quanto em Fragments (onResume, onPause, onDestroy existem em ambos contextos, embora em Fragment onDestroy signifique destruição completa do fragmento e onDestroyView seja a destruição apenas da view). Assim, a alternativa A é correta. Esse conhecimento foi reforçado nos materiais: por exemplo, vimos que para montar a UI do Fragment “CronômetroFragment” ou “ResultadoFragment”, implementamos onCreateView nele, algo que não fazemos em Activities. 

P: No projeto "Cronômetro", para zerar e reiniciar o cronômetro de volta a 00:00, qual foi a solução implementada usando o componente Chronometer?
A) Chamar chronometer.base = SystemClock.elapsedRealtime() para redefinir a base de contagem de tempo para o momento atual, e então opcionalmente chamar chronometer.start() novamente para retomar a contagem a partir de 0
B) Usar um método específico chronometer.reset() fornecido pelo componente para reiniciar a contagem
C) Parar o Chronometer e criar uma nova instância dele para começar do zero
D) Alterar o formato do Chronometer para "00:00" que automaticamente reinicia o valor interno
R: A)
E: O widget Chronometer não possui um método "reset()" direto, então para voltar a 00:00 o padrão é ajustar sua propriedade base. chronometer.base representa o timestamp (em SystemClock.elapsedRealtime()) a partir do qual o cronômetro calcula o tempo decorrido. Quando definimos chronometer.base = SystemClock.elapsedRealtime(), estamos essencialmente dizendo “considere o tempo atual como zero”. Assim, ao chamar chronometer.start() após isso, ele recomeçará do 0. Nos bastidores do projeto “Cronômetro”, esta técnica foi usada: sempre que o usuário reiniciava o cronômetro, o base era atualizado. A opção A descreve certinho esse procedimento. A alternativa B está errada – não existe chronometer.reset(). C seria uma abordagem desajeitada e não é necessária; recriar a view seria um exagero quando podemos simplesmente ajustar a base. D confunde formato visual com valor; mudar o formato (usando chronometer.setFormat) não interfere no tempo contado. Portanto, a resposta A é a correta e demonstra o entendimento prático de como manipular o Chronometer. 

P: Para navegar do Fragment X para o Fragment Y passando um argumento usando o Safe Args, qual das opções representa o código adequado?
A) val action = XFragmentDirections.actionXFragmentToYFragment(dadoArgumento); findNavController().navigate(action)
B) findNavController().navigate(R.id.action_X_to_Y, bundleOf("dado" to dadoArgumento))
C) val intent = Intent(requireActivity(), YFragment::class.java).putExtra("dado", dadoArgumento); startActivity(intent)
D) parentFragmentManager.beginTransaction().replace(R.id.container, YFragment.newInstance(dadoArgumento)).commit()
R: A)
E: A opção A utiliza exatamente o código gerado pelo Safe Args: XFragmentDirections.actionXFragmentToYFragment(...) será uma função estática gerada que cria um objeto NavDirections contendo o id da ação de navegação e o(s) argumento(s) tipados. Passamos essa action para findNavController().navigate(), o que realiza a navegação para o Fragment Y carregando junto os argumentos de forma segura. Essa é a maneira recomendada e foi usada nos projetos que utilizam Navigation + Safe Args – por exemplo, no projeto “Bebidas”, talvez algo como ListaBebidasFragmentDirections.actionListaToDetalhe(bebidaSelecionada) e então navigate(action). A opção B mostra uma navegação manual passando um Bundle. Embora funcione, ela não utiliza Safe Args (é a abordagem antiga/manual). Como a pergunta enfatiza "usando Safe Args", a alternativa B não é ideal – ela é suscetível a erro de nome de chave ou tipo. C tenta usar Intent para navegar entre Fragments, o que está errado (Intents são para Activities ou outros componentes, não se usa Intent para fragmentos dentro do mesmo NavController). D demonstra uma transação manual via FragmentManager, também contrária ao uso do Navigation Component e Safe Args (além disso, YFragment.newInstance(dado) seria um padrão manual para passar args sem Safe Args). Logo, somente a opção A está alinhada com o uso correto do Safe Args no Navigation. 

P: O que pode acontecer se chamarmos findViewById para um componente de UI antes de executar setContentView() dentro de uma Activity?
A) O findViewById retornará null porque o layout ainda não foi inflado/aplicado à Activity, possivelmente levando a um NullPointerException se tentarmos usar o resultado. É necessário chamar setContentView(primeiro) para então poder buscar os Views daquele layout
B) Não há problema – o método armazenará a referência e encontrará a View assim que o layout for inflado
C) A chamada findViewById será automaticamente adiada pelo Android até após o setContentView, funcionando normalmente
D) A Activity irá ignorar chamadas de findViewById feitas cedo demais, mas não chega a quebrar, apenas não retorna nada sem lançar erro
R: A)
E: Dentro de uma Activity, setContentView(layout) é o método que infla e anexa as Views do layout especificado à Activity. Se tentarmos acessar uma View via findViewById antes de ter chamado setContentView com o layout que a contém, a Activity ainda não tem nenhuma View carregada, e findViewById não encontrará nada (retornará null). Qualquer tentativa de usar o objeto resultante causará erro (NullPointerException). Essa é uma ordem comum de inicialização: nos projetos exemplo, sempre vemos primeiro setContentView(R.layout.algum) e depois val btn = findViewById<Button>(R.id.botao) etc. A alternativa A descreve o problema: chamar fora de ordem resulta em null. B, C e D estão incorretas – o Android não guarda chamada para depois (C), nem magicamente encontra sem o layout carregado. Na prática, chamar findViewById cedo demais leva a bugs sérios (app crash). Portanto, a opção A é correta. Por exemplo, se no projeto “Sorteador” tivéssemos por engano tentado acessar o TextView antes de setContentView, o app teria lançado um erro ao executar. 

P: Utilizando o Navigation Component, precisamos lidar manualmente com as transações de Fragment (como beginTransaction, replace, addToBackStack) no código?
A) Não. O NavController, junto com o gráfico de navegação, gerencia automaticamente as transações de Fragment de acordo com as ações definidas. Ou seja, ao usar findNavController().navigate(direcaoOuId), ele já cuida de substituir o Fragment no NavHost e controlar a pilha de navegação, sem precisarmos escrever FragmentManager.beginTransaction() manualmente
B) Sim, ainda precisamos escrever o código de transação para cada navegação, o Navigation apenas nos dá um mapa mas não executa as trocas
C) Somente para operações de retorno (popBackStack) é necessário usar FragmentManager; para navegações “para frente” o NavController cuida
D) Depende se estamos usando Safe Args – o Safe Args executa a transação automaticamente, mas sem Safe Args temos que fazer manual
R: A)
E: O objetivo do Navigation Component é simplificar a navegação. Quando configuramos um NavHostFragment e um NavController com um navGraph, as trocas de tela passam a ser feitas chamando navigate() no NavController. Internamente, ele usa o FragmentManager para substituir/empilhar fragments conforme definido, mas para nós desenvolvedores não é mais necessário escrever o boilerplate de transação (beginTransaction, commit, addToBackStack etc.) manualmente para as navegações declaradas no gráfico. Os projetos fornecidos ilustram isso: ao clicar em “Ver Detalhes” no fragmento de lista de bebidas, por exemplo, chamou-se findNavController().navigate(R.id.action_lista_to_detalhe, args) e não toda a sequência de FragmentManager. A opção A deixa claro esse comportamento. A alternativa B está incorreta – se você seguiu a configuração padrão, não precisa tocar em FragmentManager diretamente para as ações mapeadas. C também é falsa – o NavController igualmente gerencia navegação de volta, seja via popBackStack() programaticamente ou simplesmente interceptando o botão Up/Back (há inclusive NavigationUI para configurar o botão Up). D está equivocada – Safe Args é apenas para passagem de dados; com ou sem Safe Args, o Navigation executa as transações do mesmo jeito. Assim, A é a resposta correta, reforçando que o Navigation Component automatiza o gerenciamento de fragments segundo o grafo. 

P: No Android, o objeto Context é frequentemente requerido ao usar certos componentes (por exemplo, ao instanciar Toasts, Dialogs ou acessar recursos). Qual afirmativa descreve corretamente o que é o Context?
A) O Context fornece acesso aos recursos e informações globais do aplicativo. Ele representa o estado atual do aplicativo/sistema; por exemplo, uma Activity é um Context (porque herda de Context) e pode ser usado para obter serviços do sistema, inflar layouts, acessar arquivos, databases, etc.
B) Context é a tela atual que está sendo exibida na aplicação – trocar de Context equivale a trocar de tela
C) É uma classe usada apenas para manipular temas e estilos de UI dinamicamente
D) Para facilitar o acesso, é recomendado guardar o Context em variáveis estáticas globais para poder usá-lo a qualquer momento no código
R: A)
E: Context é um conceito central no Android. Ele representa o ambiente da aplicação e fornece as APIs para acessar recursos (getResources), criar objetos dependentes de UI (inflater, Toast), acessar serviços do sistema (como WIFI, LayoutInflater, etc) e informações como temas. Uma Activity ou Service são tipos de Context (eles herdam de Context), e até o Application é um Context global. A alternativa A captura essa ideia. No dia a dia, passamos this (Activity) ou requireContext() (Fragment) para métodos que precisam de Context – por exemplo, Toast.makeText(context, "Olá", Toast.LENGTH_SHORT).show() ou val inflator = context.getSystemService(LAYOUT_INFLATER_SERVICE). As outras alternativas estão incorretas: B confunde Context com “tela” – embora Activity seja context e represente uma tela, o conceito de Context é mais amplo (Fragment tem context mas não é tela por si; Application é um context sem tela). C é muito limitada (Context faz muito mais que temas). D é uma má prática – guardar context em variável estática pode impedir que ele seja liberado (leak de memória); geralmente passamos context como e quando necessário, não o mantém global salvo quando não precisa. Assim, a explicação A é a correta. Nos projetos, sempre que abrimos uma Dialog ou Toast no código, tivemos que passar um context válido – frequentemente era a Activity ou o Fragment (requireContext). 

P: Quando o usuário volta para uma Activity que estava em segundo plano (por exemplo, retornando a uma tela que foi minimizada ou sobreposta por outra Activity), qual sequência de métodos de ciclo de vida é executada nessa Activity?
A) onRestart() -> onStart() -> onResume()
B) onStart() -> onResume() -> onPause()
C) onCreate() -> onStart() -> onResume()
D) somente onResume(), já que a Activity já estava criada
R: A)
E: Quando uma Activity estava previamente em estado onStop (parada, oculta, mas ainda existente na memória) e o usuário retorna a ela, o sistema chama onRestart() seguido de onStart() e então onResume(). onRestart() indica que a Activity está sendo retomada após ter sido parada. Em seguida onStart torna a Activity visível novamente, e onResume a coloca em primeiro plano interativo. Isso foi visto em aula: por exemplo, se do app “Bebidas” o usuário pressionar Home e depois voltar ao app, a Activity principal passa por onRestart->onStart->onResume. A opção B está errada porque onPause não faria parte da sequência de retorno (onPause ocorre ao sair do primeiro plano, não ao entrar). C descreve a sequência de criação inicial, não de retorno – onCreate não é chamado nesse caso porque a Activity não foi destruída, apenas parada. D está incorreta pois onRestart e onStart também ocorrem, não é só onResume isoladamente. Portanto, a resposta A está correta. 

P: No contexto de uma lista exibida com RecyclerView, qual é o papel de um Adapter?
A) O Adapter é responsável por criar as views de cada item e vincular (bind) os dados a essas views, gerenciando a reciclagem das views. Em outras palavras, ele pega os dados da fonte (lista) e “adapta” para a forma de itens visuais que o RecyclerView apresenta, reusando as views quando possível
B) O Adapter define o layout geral (geral, não de cada item) que o RecyclerView irá apresentar e controla a disposição das views na tela (como um gerente de layout)
C) O Adapter é opcional – serve apenas para otimizar performance, mas o RecyclerView consegue popular itens sozinho se os dados estiverem em um List ou Array
D) O Adapter carrega automaticamente dados de um banco de dados ou web quando conectado ao RecyclerView, sem código adicional
R: A)
E: O Adapter do RecyclerView atua como o intermediário entre os dados e as Views. Ele cria ViewHolders (que contêm as Views dos itens) no método onCreateViewHolder e preenche os dados nesses ViewHolders em onBindViewHolder. Também informa quantos itens existem (getItemCount). Em resumo, ele “adapta” cada elemento da sua coleção de dados para um item visual. Por exemplo, no projeto “Bebidas”, deve ter havido um Adapter para apresentar cada bebida em uma lista – esse adapter inflaria um layout de item (talvez contendo nome e imagem da bebida) e inseriria os dados da bebida nessa view, reciclando views antigos à medida que rolamos. A opção A reflete exatamente isso. As outras opções são incorretas: B confunde com o LayoutManager (quem gerencia disposição é o LayoutManager, como LinearLayoutManager, GridLayoutManager, não o adapter). C está errada – o RecyclerView exige um Adapter, ele não faz nada sozinho sem adapter. D também é errada – o Adapter não busca dados automagicamente; ele apenas consome a lista de dados que você já obteve (seja de memória, banco ou web, mas a lógica de obter/popular a lista é do programador). Portanto, A é a resposta certa. 

P: Ao utilizar o Safe Args, o Gradle Plugin gera classes auxiliares para cada destino e ação de navegação. Por exemplo, se temos um Fragment ListaFragment que navega para DetalheFragment passando argumentos, quais classes o Safe Args provavelmente gerará para facilitar essa navegação?
A) Uma classe ListaFragmentDirections contendo métodos para cada ação de ListaFragment (por ex, actionListaFragmentToDetalheFragment) e uma classe DetalheFragmentArgs contendo os campos dos argumentos esperados por DetalheFragment
B) Uma classe ListaFragmentArgs e uma DetalheFragmentDirections
C) Apenas uma única classe NavGraphDirections com métodos estáticos para todos os caminhos de navegação
D) Nenhuma classe – o Safe Args injeta funções diretamente nos Fragments de origem e destino ao compilar
R: A)
E: O Safe Args segue convenções: para cada Fragment que declara ações de navegação no nav_graph, é gerada uma classe NomeDoFragmentDirections. Essa classe terá métodos estáticos correspondentes a cada ação de navegação saindo desse fragmento, facilitando criar o NavDirections com argumentos. E para cada Fragment de destino com argumentos declarados, é gerada uma classe NomeDoFragmentArgs com os getters para aqueles parâmetros (e eventualmente um Companion object com fromBundle). No exemplo dado, ListaFragment tem uma ação para DetalheFragment -> teremos ListaFragmentDirections com um método actionListaFragmentToDetalheFragment(dados necessários), e DetalheFragment (que recebe argumentos) terá DetalheFragmentArgs para recuperar esses dados. A alternativa A está correta quanto a essas classes. A opção B inverte as classes – na verdade Directions pertence ao de origem e Args ao de destino, não o contrário. C está errada – NavGraphDirections é gerada em alguns casos para ações globais (global actions), mas geralmente cada fragment tem sua Directions. Mesmo assim, DetalheFragmentArgs ainda existiria para argumentos específicos. D também está errada; não há injeção direta de métodos nos fragmentos originais, e sim classes separadas. Assim, a resposta A reflete com precisão a saída do Safe Args. 

P: Em uma implementação de lista (RecyclerView) de bebidas, desejamos detectar quando o usuário clica em um item específico da lista para então navegar para os detalhes daquela bebida. Qual é uma maneira adequada de implementar essa detecção de clique em cada item?
A) Implementar um listener na classe Adapter, de forma que cada ViewHolder tenha, por exemplo, um setOnClickListener que chama uma interface de callback para Activity/Fragment. Dessa forma, quando um item for clicado, o Adapter notifica o Fragment/Activity qual item foi selecionado, permitindo abrir a tela de detalhe correspondente
B) Utilizar diretamente o método setOnItemClickListener do RecyclerView para receber o evento de clique do item selecionado
C) Definir o atributo android:onClick no layout do item, apontando para um método na Activity, e todos os cliques nos itens serão tratados por esse mesmo método
D) O RecyclerView já trata cliques em itens automaticamente se os itens forem focoáveis, então não é necessário código extra – basta implementar o método onItemClicked da Activity
R: A)
E: O RecyclerView não fornece um onItemClick pronto (diferente de ListView que tinha AdapterView.OnItemClickListener). A prática comum é a alternativa A: dentro do Adapter ou ViewHolder, configurar um listener para cada item. Pode-se passar uma interface/callback para o Adapter via construtor – por exemplo, onBebidaClicked(bebida) – que o Fragment/Activity implementa. Assim, quando o usuário clicar em um item (poderia ser definindo itemView.setOnClickListener no ViewHolder), o adapter chama callback com a posição ou objeto. Nos projetos, provavelmente foi usada abordagem semelhante para, por exemplo, ao clicar em uma bebida na lista, chamar o NavController.navigate passando aquela bebida. A opção B está errada porque RecyclerView não tem setOnItemClickListener nativo. C até poderia funcionar de modo limitado (você teria que ter um único método na Activity para múltiplos itens e descobrir qual foi clicado através da View, o que é complicado e menos flexível). O mais comum mesmo é via Adapter. D é incorreto – não existe onItemClicked padrão em Activity; a menção a itens focoáveis é irrelevante para clique. Assim, a resposta A reflete a solução típica usada para tratar eventos de clique em RecyclerView. 

P: Qual método do ciclo de vida da Activity é chamado quando a Activity se torna totalmente invisível para o usuário, por exemplo, quando outra Activity cobre toda a tela?
A) onStop()
B) onPause()
C) onDestroy()
D) onInvisible() (não existe)
R: A)
E: Quando uma Activity deixa de estar visível (totalmente encoberta por outra ou o usuário saiu do app), o Android chama onStop(). A diferença entre onPause e onStop é sutil: onPause() acontece quando a Activity perde o foco (ficando parcialmente ou totalmente oculta), mas ela pode ainda estar parcialmente visível (por exemplo, aparecendo em segundo plano se outra janela semi-transparente estiver na frente, ou em modo multi-janela). onStop(), por sua vez, indica que a Activity não está mais visível nenhuma parte – a UI não é mais vista pelo usuário. Nos materiais, o ciclo de vida deixa claro: “Paused” = não interativa mas ainda pode estar visível; “Stopped” = completamente oculta. Portanto, a resposta é onStop() para invisibilidade total. A opção B (onPause) está incorreta para “totalmente invisível” (onPause é chamada antes, no momento que ficou sem foco, mas não garante ausência completa da interface). C onDestroy não é necessariamente chamado ao ficar invisível – onDestroy vem depois, se a Activity for finalizada. D é inexistente. Assim, a alternativa A é certa. Um exemplo prático: no projeto “Bebidas”, se ao abrir a tela de detalhes (Activity B) ela cobre toda a tela, a Activity de lista (Activity A) receberá onPause seguido de onStop (ficou completamente oculta). Quando fechamos B e voltamos a A, A chamará onRestart->onStart->onResume, mostrando que ela tinha parado. 

P: Além de declarar Activities, que outras coisas importantes costumam ser definidas no AndroidManifest.xml de um aplicativo?
A) As permissões que o app necessita (via <uses-permission>), o nome do pacote (applicationId), a versão do aplicativo, o ícone e label (nome) exibidos ao usuário, os componentes como Services, BroadcastReceivers, ContentProviders e também o tema global da aplicação
B) O código fonte Java/Kotlin de cada classe usada no aplicativo
C) Os layouts de todas as telas do aplicativo em formato XML
D) As dependências de bibliotecas de terceiros usadas pelo aplicativo
R: A)
E: O AndroidManifest.xml é como um “registro” do aplicativo para o sistema Android. Nele, além das Activities (com seus filtros de Intent), declaramos permissões (por exemplo, acesso à internet, câmera, localização – sem esta declaração no manifest, o app não pode usar recursos protegidos). Também definimos metadata como a versão (versionCode, versionName), o ícone e nome do aplicativo (atributos da tag <application>), os temas padrão, além de registrar outros componentes: Services (serviços em background), BroadcastReceivers e ContentProviders devem constar no manifest para serem reconhecidos pelo sistema. Nos projetos, por exemplo, se um Service auxiliar fosse usado ou se precisássemos permitir internet para buscar dados de bebidas, teríamos <uses-permission android:name="android.permission.INTERNET" /> no manifest. As outras alternativas estão erradas: B – o código fonte não vai no manifest (ele está nos .java/.kt compilados em .dex); C – layouts ficam em res/layout, não no manifest; D – dependências são tratadas no Gradle, não no manifest. Portanto, a alternativa A é a correta, enumerando vários elementos importantes configuráveis no manifest. 

P: No ConstraintLayout, por que é necessário definir pelo menos duas restrições (constraints) ortogonais para cada view (uma horizontal e uma vertical)?
A) Porque cada view precisa saber como se posicionar tanto no eixo horizontal quanto no vertical em relação a outros elementos ou ao contêiner. Sem duas constraints (por exemplo, esquerda/direita e topo/base definidas), a posição ficaria indeterminada ou a view poderia simplesmente ficar em uma posição padrão (canto) ou até não ser exibida. Definir as constraints corretamente garante que o layout do ConstraintLayout seja bem definido e estável em diferentes telas
B) Porque o Android Studio exige isso apenas para gerar o XML, mas em tempo de execução não faz diferença
C) Para aplicar o padrão de design MVC, onde cada View precisa de duas camadas de restrição
D) Porque o ConstraintLayout automaticamente duplica cada view, então é preciso duas constraints para amarrar as duas instâncias
R: A)
E: O ConstraintLayout funciona estabelecendo relações (restrições) entre edges (bordas) das views. Cada view deve ter pelo menos uma constraint horizontal (por exemplo: alinhada a algum lado do pai, ou centrada, ou ligada a outra view horizontalmente) e uma vertical. Se faltar uma das direções, o layout terá dificuldade em calcular a posição ou tamanho da view. O Android Studio inclusive avisa com um símbolo de alerta se alguma view não tiver constraint suficiente. A opção A está correta e explica que sem essas restrições a posição/tamanho da view pode ficar indefinido. Por exemplo, nos layouts dos projetos, ao colocar um Button no ConstraintLayout, atribuímos constraints como app:layout_constraintTop_toTopOf="parent" e app:layout_constraintStart_toStartOf="parent" (ou a outro elemento). Caso esquecêssemos uma delas, o botão poderia saltar para 0,0 ou comportamento inesperado. As outras opções são absurdas/inverídicas: B não é apenas “exigência do Android Studio”, é o funcionamento real do layout; C não tem nada a ver com MVC; D é sem sentido. Assim, A esclarece corretamente. 

P: Qual é a diferença entre margin e padding em um View (componente de interface) no Android?
A) Margin é o espaço externo à view, ou seja, a distância que separa a view de outros elementos ao seu redor (definido no container), enquanto padding é o espaço interno da view, a distância entre seu conteúdo (texto, imagem) e as bordas internas da própria view
B) Não há diferença; margin e padding são termos intercambiáveis nos layouts Android
C) Margin se aplica apenas a layouts do tipo LinearLayout, enquanto padding se aplica a ConstraintLayouts
D) Padding aumenta o tamanho total da view, já margin não afeta o tamanho da view
R: A)
E: Margin e Padding são conceitos de layout: margin é para fora, padding é para dentro. Se um TextView tem padding de 8dp, por exemplo, o texto exibido dentro dele ficará afastado 8dp de cada borda da caixinha do TextView, aumentando a área interna clicável e o espaço em fundo. Já margin de 8dp em um TextView deixará um espaço de 8dp entre a borda externa desse TextView e o próximo elemento ou o contêiner. Visualmente, margin “empurra” os elementos vizinhos ou contêiner, enquanto padding “empurra” o conteúdo para longe da borda do próprio componente. A opção A capta isso corretamente. B está errada – margin e padding não são a mesma coisa. C está incorreta – margin e padding existem para qualquer View, independentemente do contêiner (LinearLayout, ConstraintLayout etc). D está parcialmente confusa: padding realmente acaba aumentando o espaço ocupado pela view (pois a view inclui seu conteúdo + padding como tamanho total), margin também pode afetar o posicionamento relativo mas não altera as dimensões intrínsecas da view (apenas acrescenta espaço ao redor). De toda forma, a definição pedida é a de A. Nos layouts dos projetos, por exemplo, vimos uso de padding em containers (LinearLayout com padding para dar respiro interno) e margin entre botões para separá-los. 

P: Qual unidade de medida é recomendada para definir tamanhos de fonte (textSize) na interface Android, e por quê?
A) sp (scale-independent pixels), porque além de ser independente da densidade da tela como o dp, ela respeita as preferências de acessibilidade do usuário em relação ao tamanho da fonte. Ou seja, usando sp, se o usuário aumentar o tamanho de fonte nas configurações do dispositivo, o texto do app escalará proporcionalmente, melhorando a legibilidade
B) dp, pois textos não precisam considerar preferências do usuário, apenas densidade de tela
C) px, para ter controle exato pixel a pixel do tamanho da fonte em todas as telas
D) pt (pontos tipográficos), porque são medidas padronizadas na indústria gráfica
R: A)
E: Para textos, a convenção é usar sp. Essa unidade funciona quase igual ao dp em termos de densidade de tela, porém inclui a escalabilidade de acordo com as preferências do usuário (configuração “Tamanho da fonte” ou “Fonte grande” no Android). Isso garante acessibilidade – usuários com dificuldade podem aumentar o tamanho padrão das fontes e o aplicativo acompanhará. As alternativas B e C são práticas não recomendadas: dp não escalaria com as preferências de fonte (um texto definido em 14dp ficará sempre 14px em 160dpi, não aumentando para usuários que preferem fonte maior), px então pior ainda porque nem ajusta por densidade. D (pontos) não é normalmente usada em Android UI design; px e pt são unidades absolutas, não adequadas para variedade de telas. Portanto, A é correta. Essa recomendação provavelmente foi mencionada em “Conceitos principais”: sempre que definimos android:textSize="16sp" nos layouts dos projetos, seguimos essa prática de usar sp para texto e dp para dimensões de view. 

P: Para que serve um BroadcastReceiver no Android?
A) Para receber e tratar broadcasts (mensagens ou eventos) enviados pelo próprio sistema ou por aplicativos. Por exemplo, um BroadcastReceiver pode ouvir quando o dispositivo concluiu a inicialização (BOOT_COMPLETED), ou quando a conectividade muda, ou quando chega um SMS, e então executar alguma ação em resposta a esses eventos globais
B) Para manter uma tarefa em segundo plano executando constantemente, semelhante a um Service porém com interface
C) Para enviar dados entre Activities de forma mais rápida do que usando Intent
D) É um componente destinado exclusivamente a receber notificações push da internet
R: A)
E: BroadcastReceivers são um dos quatro componentes base do Android. Eles recebem broadcasts, que são anúncios de eventos. O sistema Android emite vários broadcasts (bateria fraca, mudança de fuso horário, instalação de pacote, etc) e apps também podem emitir seus próprios. Um BroadcastReceiver que esteja registrado (no manifest ou dinamicamente) para uma determinada ação será despertado quando esse evento ocorrer e poderá executar código breve em resposta (porque BroadcastReceiver tem que fazer tarefas rápidas, em segundos). Nos materiais de conceito, deve ter sido citado este componente, ainda que nossos projetos não tenham implementado um (pois apps simples raramente precisam). A opção A é a definição correta. B está descrevendo mais um Service (tarefas contínuas) – Receivers não mantêm execução prolongada, eles recebem o evento e finalizam. C não tem relação – troca de dados entre Activities é feita via Intent extras ou outras técnicas, broadcast não é para esse fim (a não ser em casos muito específicos). D – embora um tipo de broadcast possa ser originado de mensagens push (via Firebase etc), um BroadcastReceiver não é exclusivo para push; essa opção é limitante e confusa. Então, a alternativa A é a que abrange corretamente a função do BroadcastReceiver. 

P: Em que situação é apropriado usar um Service no Android?
A) Quando precisamos executar uma tarefa de longa duração ou em segundo plano sem interface com o usuário, por exemplo tocar música, monitorar localização GPS contínua ou baixar um arquivo, mesmo que o usuário saia da tela – um Service continua rodando (em primeiro ou segundo plano) independentemente de Activities.
B) Quando queremos uma tela modal aparecendo sobre a Activity atual
C) Para armazenar dados localmente no dispositivo de forma persistente
D) Para executar operações de desenho gráfico na UI thread
R: A)
E: Um Service é um componente para processamento de fundo. Ele não fornece UI e não interrompe a interação do usuário com o app. É adequado para tarefas que precisam continuar rodando mesmo se nenhuma Activity estiver visível. Por exemplo, um player de música usa um Service para continuar tocando som enquanto o usuário navega em outras telas; ou um app pode usar um Service para sincronizar dados com servidor periodicamente. A opção A traz esses exemplos e é correta. B está descrevendo possivelmente um Dialog ou Activity transparente – não é papel de Service. C (armazenar dados) seria feito via banco de dados, SharedPreferences, ContentProvider etc., não necessariamente um Service. D (desenho gráfico na UI thread) – operações de UI devem ocorrer na Activity/Fragment (UI thread), não em um Service (que por padrão roda na main thread também, mas sem UI – usar service pra isso não tem sentido). Portanto, usar um Service faz sentido na situação da alternativa A. Apesar de nossos projetos não terem criado Services, esse conceito foi abordado nos “conceitos principais” de componentes. 

P: Para que serve um ContentProvider no Android?
A) Para permitir o compartilhamento de dados entre aplicações de forma controlada. Um ContentProvider abstrai um conjunto de dados (por exemplo, contatos, fotos, etc.) e fornece métodos (via URI) para que outros aplicativos (com permissões adequadas) consultem ou modifiquem esses dados. Exemplos: o Android fornece ContentProviders para contatos do telefone, mídia, etc., e um aplicativo pode expor dados próprios através de um ContentProvider
B) Para fazer requisições HTTP para servidores web e prover os resultados à aplicação
C) Para renderizar conteúdo visual em Views customizadas
D) É um componente usado unicamente pelo sistema, apps de terceiros não implementam ContentProvider
R: A)
E: ContentProvider é o componente Android projetado para acesso a dados de uma aplicação por outras aplicações, através de uma interface de URI padronizada. Quando se quer tornar dados acessíveis externamente ou compartilhar entre diferentes partes do app (por exemplo, entre processos), usa-se um ContentProvider. O sistema Android utiliza ContentProviders para permitir que apps leiam, por exemplo, os contatos (via content://contacts/...), ou galerias de imagens, etc., de forma segura. Um app também pode implementar seu próprio, mas é menos comum a menos que seja necessário compartilhar dados amplamente. A opção A está correta. B não tem a ver – requisições HTTP quem faz é normalmente uma AsyncTask, HttpUrlConnection, Retrofit etc., não um ContentProvider. C trata de UI customizada – não é o caso (ContentProvider não lida com UI). D está errada – apps podem sim implementar ContentProviders (ex: um app de notas poderia expor suas notas via ContentProvider para integração com outros apps). Logo, A é a resposta correta e condiz com a explicação dada em conceitos iniciais. 

P: No Gradle (build.gradle) do módulo app, encontramos configurações como compileSdkVersion e minSdkVersion. Qual a diferença entre elas?
A) compileSdkVersion define a versão da API do Android utilizada para compilar o aplicativo (a versão das bibliotecas de cabeçalhos contra as quais o app é construído, permitindo uso de recursos até essa API), enquanto minSdkVersion indica a versão mínima do Android requerida para rodar o aplicativo. Ou seja, minSdkVersion = API mais baixa suportada em execução; compileSdkVersion = API do kit de desenvolvimento usado na compilação
B) compileSdkVersion e minSdkVersion devem sempre ter o mesmo valor; representam ambos a API alvo do aplicativo
C) compileSdkVersion é a versão máxima suportada pelo app e minSdkVersion a versão mínima, e o app só rodará exatamente entre essas duas (não incluindo versões futuras à compileSdk)
D) compileSdkVersion refere-se à versão do Java ou Kotlin usada, enquanto minSdkVersion refere-se à versão do Android
R: A)
E: Essa é uma configuração importante do Gradle: por exemplo, compileSdkVersion 33 e minSdkVersion 21 significam que o app foi compilado com os APIs da versão 33 (Android 13), podendo usar funcionalidades disponíveis até essa API (desde que providencie condicionais ou utilize bibliotecas de suporte para APIs superiores à minSdk), e que ele suporta rodar em qualquer aparelho com Android Lollipop (5.0, API 21) ou superior. Em nossos projetos, escolhemos uma minSdk possivelmente algo como 21 ou 23 e compileSdk a versão do Android mais recente disponível. A opção A reflete corretamente essa distinção. B está errada – não precisam ser iguais (geralmente compileSdk é a mais alta possível para ter acesso a recursos novos, enquanto minSdk é mais baixa para alcançar mais dispositivos). C – o app rodará em versões futuras à compileSdk também (por compatibilidade forward, normalmente), compileSdk não limita a execução, apenas a compilação; já targetSdkVersion (não mencionada na pergunta) tem outro papel – talvez haja confusão, mas aqui pedimos compile vs min. D – compileSdk não tem relação com versão de Java/Kotlin. Portanto, A é a resposta precisa. 

P: O que significa o termo AndroidX em um projeto Android?
A) Refere-se ao conjunto de bibliotecas de suporte e bibliotecas Jetpack modernas que substituíram as antigas Support Libraries. Basicamente, AndroidX é o namespace (pacote) prefixo para as bibliotecas Android de suporte (como AppCompat, RecyclerView, Navigation, etc.), garantindo padronização e modularização. Projetos recentes usam AndroidX por padrão
B) É o codinome da versão específica do Android usada pelo projeto, indicando uma versão experimental do sistema operacional
C) Significa que o projeto está usando extensões de sintaxe Kotlin (Android Extensions)
D) AndroidX é um plugin do Android Studio necessário para habilitar o ViewBinding e Safe Args
R: A)
E: AndroidX é uma grande iniciativa de reorganização das bibliotecas de suporte lançada pela Google. Todas as classes que antes estavam em pacotes como android.support.v7... foram migradas para androidx.* a partir de 2019. Por exemplo, a antiga Support Library AppCompat v7 tornou-se androidx.appcompat.app.AppCompatActivity, etc. O termo também engloba as novas bibliotecas Jetpack que seguem esse novo namespace e padrões de versão independente do framework Android. Em suma, se seu projeto está “usando AndroidX”, significa que está utilizando as bibliotecas atualizadas e recomendadas. A opção A explica corretamente. As demais opções estão incorretas: B não faz sentido – AndroidX não é uma versão do sistema, é sobre bibliotecas. C confunde com Kotlin Android Extensions (extensões para view binding sintético, recurso antigo descontinuado) – não é isso. D – AndroidX não é um plugin específico do Android Studio para tais recursos; ViewBinding e Safe Args são parte do Jetpack, sim, mas AndroidX é mais abrangente. Portanto, A é a certa. 

P: Suponha que seu aplicativo precise de acesso à internet. O que é necessário para permitir isso?
A) Incluir no AndroidManifest.xml a linha <uses-permission android:name="android.permission.INTERNET" />. Sem essa permissão declarada, o app não poderá realizar requisições de rede
B) Ativar o acesso à internet nas configurações do Gradle, seção internetConfig
C) Nada – todo app Android tem acesso à internet por padrão
D) Chamar um método NetworkManager.requestInternetAccess() na inicialização do app
R: A)
E: Para acessar recursos protegidos, como Internet, é preciso declarar permissão no manifest. A permissão de Internet é uma das mais básicas e não requer aprovação explícita do usuário (ela é do grupo normal), mas precisa estar no manifest ou as chamadas de rede resultarão em falha. Portanto, a opção A está correta: colocar <uses-permission android:name="android.permission.INTERNET" /> dentro do manifest. Os projetos fornecidos possivelmente mencionam isso – por exemplo, se o “Texto Encriptografado II” enviasse ou recebesse algo online (não parece o caso, mas se fosse, precisaria declarar). B é inexistente – não se configura permissão via Gradle dessa forma. C está errada – por padrão nenhuma permissão é concedida sem declarar; Internet não é automática. D não existe no SDK. Logo, a alternativa A reflete o procedimento necessário para permitir operações de rede no app.